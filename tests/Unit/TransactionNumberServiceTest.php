<?php

namespace Tests\Unit;

use Tests\TestCase;
use App\Services\TransactionNumberService;
use App\Models\TransactionSeries;
use App\Models\Transaction;
use App\Models\User;
use App\Models\OrNumberGeneration;
use App\Models\TransactionSeriesUserCounter;
use Illuminate\Foundation\Testing\RefreshDatabase;
use Illuminate\Support\Facades\DB;
use Exception;

class TransactionNumberServiceTest extends TestCase
{
    use RefreshDatabase;

    protected TransactionNumberService $service;
    protected User $user;

    protected function setUp(): void
    {
        parent::setUp();
        $this->service = new TransactionNumberService();
        $this->user = User::factory()->create();
    }

    /**
     * Test generating the first OR number from a new series.
     */
    public function test_generate_first_or_number()
    {
        // Authenticate user for multi-cashier support
        $this->actingAs($this->user);
        
        // Create an active series (global, not assigned to specific user)
        $series = TransactionSeries::create([
            'series_name' => '2025 Test Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $result = $this->service->generateNextOrNumber($this->user->id);

        $this->assertIsArray($result);
        $this->assertArrayHasKey('or_number', $result);
        $this->assertArrayHasKey('series_id', $result);
        $this->assertArrayHasKey('generation_id', $result);
        $this->assertEquals($series->id, $result['series_id']);
        
        // Check that OR number format is correct
        $this->assertStringStartsWith('OR', $result['or_number']);
        $this->assertStringContainsString('000000000001', $result['or_number']);
        
        // Verify generation record was created
        $generation = OrNumberGeneration::find($result['generation_id']);
        $this->assertNotNull($generation);
        $this->assertEquals('generated', $generation->status);
        $this->assertEquals(1, $generation->actual_number);
        $this->assertEquals($this->user->id, $generation->generated_by_user_id);
    }

    /**
     * Test sequential OR number generation.
     */
    public function test_generate_sequential_or_numbers()
    {
        // Authenticate user
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => '2025 Test Series',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Generate multiple OR numbers
        $result1 = $this->service->generateNextOrNumber($this->user->id);
        $result2 = $this->service->generateNextOrNumber($this->user->id);
        $result3 = $this->service->generateNextOrNumber($this->user->id);

        // Verify they are sequential
        $this->assertStringContainsString('000000000001', $result1['or_number']);
        $this->assertStringContainsString('000000000002', $result2['or_number']);
        $this->assertStringContainsString('000000000003', $result3['or_number']);

        // Verify all generated by same user
        $this->assertEquals(3, OrNumberGeneration::where('generated_by_user_id', $this->user->id)->count());
    }

    /**
     * Test OR number format with different templates.
     */
    public function test_or_number_format_with_custom_template()
    {
        // Authenticate user
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Custom Format Series',
            'prefix' => 'OR2',
            'current_number' => 0,
            'start_number' => 100,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:8}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $result = $this->service->generateNextOrNumber($this->user->id);
        
        $this->assertStringStartsWith('OR2', $result['or_number']);
        $this->assertStringContainsString('00000100', $result['or_number']);
    }

    /**
     * Test that an exception is thrown when no active series exists.
     */
    public function test_throws_exception_when_no_active_series()
    {
        // Authenticate user but don't create any active series
        $this->actingAs($this->user);
        
        $this->expectException(Exception::class);
        $this->expectExceptionMessage('No active transaction series found');

        $this->service->generateNextOrNumber($this->user->id);
    }

        /**
     * Test series end limit is properly enforced.
     * Verifies that attempting to generate beyond the series limit throws an exception.
     */
    public function test_series_end_limit_behavior()
    {
        // Authenticate user
        $this->actingAs($this->user);
        
        // Create a series with a very low limit
        $series = TransactionSeries::create([
            'series_name' => '2025 Limited Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 3,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Generate the 3 allowed numbers
        $result1 = $this->service->generateNextOrNumber($this->user->id);
        $this->assertStringContainsString('000000000001', $result1['or_number']);
        
        $result2 = $this->service->generateNextOrNumber($this->user->id);
        $this->assertStringContainsString('000000000002', $result2['or_number']);
        
        $result3 = $this->service->generateNextOrNumber($this->user->id);
        $this->assertStringContainsString('000000000003', $result3['or_number']);

        // Fourth attempt should throw exception as series is exhausted
        $this->expectException(Exception::class);
        $this->expectExceptionMessage('has reached its limit');
        
        $this->service->generateNextOrNumber($this->user->id);
    }

    /**
     * Test validating manual OR numbers.
     */
    public function test_validate_manual_or_number_unique()
    {
        // Valid OR number (doesn't exist)
        $isValid = $this->service->validateManualOrNumber('OR-202510-999999');
        $this->assertTrue($isValid);
    }

    /**
     * Test validating duplicate manual OR numbers.
     */
    public function test_validate_manual_or_number_duplicate()
    {
        // Create a transaction with an OR number
        Transaction::factory()->create([
            'or_number' => 'OR-202510-123456',
        ]);

        // Try to validate the same OR number
        $isValid = $this->service->validateManualOrNumber('OR-202510-123456');
        $this->assertFalse($isValid);
    }

    /**
     * Test creating a new series.
     */
    public function test_create_series()
    {
        $data = [
            'series_name' => 'New Series 2026',
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => false,
            'effective_from' => '2026-01-01',
            'created_by' => $this->user->id,
        ];

        $series = $this->service->createSeries($data);

        $this->assertInstanceOf(TransactionSeries::class, $series);
        $this->assertEquals('New Series 2026', $series->series_name);
        $this->assertFalse($series->is_active);
    }

    /**
     * Test creating an active series deactivates other series for the same user.
     */
    public function test_create_active_series_deactivates_others()
    {
        // Create an existing active series (global)
        $oldSeries = TransactionSeries::create([
            'series_name' => 'Old Active Series',
            'current_number' => 100,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Create a new active series (global)
        $newSeries = $this->service->createSeries([
            'series_name' => 'New Active Series',
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->addYear()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Verify old series was deactivated (auto-deactivation of previous active series)
        $oldSeries->refresh();
        $this->assertFalse($oldSeries->is_active);
        $this->assertTrue($newSeries->is_active);
    }

    /**
     * Test activating a series.
     */
    public function test_activate_series()
    {
        $series = TransactionSeries::create([
            'series_name' => 'Inactive Series',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => false,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $this->service->activateSeries($series);

        $series->refresh();
        $this->assertTrue($series->is_active);
    }

    /**
     * Test activating a series deactivates other series for the same user.
     */
    public function test_activate_series_deactivates_others()
    {
        $series1 = TransactionSeries::create([
            'series_name' => 'Series 1',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $series2 = TransactionSeries::create([
            'series_name' => 'Series 2',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => false,
            'effective_from' => now()->addYear()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Activate series 2 (should deactivate series 1 globally)
        $this->service->activateSeries($series2);

        $series1->refresh();
        $series2->refresh();

        $this->assertFalse($series1->is_active);
        $this->assertTrue($series2->is_active);
    }

    /**
     * Test deactivating a series.
     */
    public function test_deactivate_series()
    {
        $series = TransactionSeries::create([
            'series_name' => 'Active Series',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $this->service->deactivateSeries($series);

        $series->refresh();
        $this->assertFalse($series->is_active);
    }

    /**
     * Test getting active series.
     */
    public function test_get_active_series()
    {
        // Create multiple series with only one active
        TransactionSeries::create([
            'series_name' => 'Inactive Series',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => false,
            'effective_from' => now()->subYear()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $activeSeries = TransactionSeries::create([
            'series_name' => 'Active Series',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $result = $this->service->getActiveSeries();

        $this->assertNotNull($result);
        $this->assertEquals($activeSeries->id, $result->id);
        $this->assertEquals('Active Series', $result->series_name);
    }

    /**
     * Test getting series statistics.
     */
    public function test_get_series_statistics()
    {
        $series = TransactionSeries::create([
            'series_name' => 'Test Series',
            'current_number' => 500,
            'start_number' => 1,
            'end_number' => 1000,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $stats = $this->service->getSeriesStatistics($series);

        $this->assertIsArray($stats);
        $this->assertEquals('Test Series', $stats['series_name']);
        $this->assertEquals(500, $stats['current_number']);
        $this->assertEquals(50.0, round($stats['usage_percentage'], 1)); // 500/1000 = 50%
        $this->assertEquals(500, $stats['remaining_numbers']);
        $this->assertFalse($stats['is_near_limit']); // Below 90%
        $this->assertFalse($stats['has_reached_limit']);
    }

    /**
     * Test checking if series is near limit.
     */
    public function test_check_series_near_limit()
    {
        $series = TransactionSeries::create([
            'series_name' => 'Nearly Full Series',
            'current_number' => 950,
            'start_number' => 1,
            'end_number' => 1000,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $warning = $this->service->checkSeriesNearLimit();

        $this->assertNotNull($warning);
        $this->assertEquals('Nearly Full Series', $warning['series_name']);
        $this->assertTrue($warning['is_near_limit']);
    }

    /**
     * Test thread-safe OR number generation (concurrent requests).
     */
    public function test_concurrent_or_number_generation()
    {
        // Authenticate user
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Concurrent Test Series',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $orNumbers = [];

        // Simulate concurrent requests by generating multiple OR numbers
        // in rapid succession (database locking should prevent duplicates)
        DB::transaction(function () use (&$orNumbers) {
            for ($i = 0; $i < 10; $i++) {
                $result = $this->service->generateNextOrNumber($this->user->id);
                $orNumbers[] = $result['or_number'];
            }
        });

        // Verify all OR numbers are unique
        $uniqueOrNumbers = array_unique($orNumbers);
        $this->assertCount(10, $uniqueOrNumbers);

        // Verify they are sequential
        $this->assertStringContainsString('000000000001', $orNumbers[0]);
        $this->assertStringContainsString('000000000010', $orNumbers[9]);
    }

    /**
     * Test updating a series.
     */
    public function test_update_series()
    {
        $series = TransactionSeries::create([
            'series_name' => 'Original Name',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => false,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        $updated = $this->service->updateSeries($series, [
            'series_name' => 'Updated Name',
            'notes' => 'Test notes',
        ]);

        $this->assertEquals('Updated Name', $updated->series_name);
        $this->assertEquals('Test notes', $updated->notes);
    }

    /**
     * Test series with no end number (unlimited).
     */
    public function test_series_with_no_end_number()
    {
        // Authenticate user
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Unlimited Series',
            'current_number' => 999998,
            'start_number' => 1,
            'end_number' => null, // No limit
            'prefix' => 'OR',
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Set user counter to high number
        TransactionSeriesUserCounter::create([
            'user_id' => $this->user->id,
            'transaction_series_id' => $series->id,
            'last_generated_number' => 999998,
            'start_offset' => 999998,
            'is_auto_assigned' => true,
        ]);

        // Should be able to generate numbers without hitting limit
        $result = $this->service->generateNextOrNumber($this->user->id);
        $this->assertNotNull($result);
        
        $stats = $this->service->getSeriesStatistics($series->fresh());
        $this->assertFalse($stats['has_reached_limit']);
        $this->assertFalse($stats['is_near_limit']);
        $this->assertNull($stats['remaining_numbers']);
    }

    /**
     * Test stateless offset parameter on first generation.
     */
    public function test_stateless_offset_on_first_generation()
    {
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Test Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Generate with offset=50 (stateless)
        $result = $this->service->generateNextOrNumber($this->user->id, 50);
        
        // Verify OR starts at 50
        $this->assertStringContainsString('000000000050', $result['or_number']);
        $this->assertEquals(50, $result['actual_number']);
    }    /**
     * Test preview with stateless offset.
     */
    public function test_preview_with_stateless_offset()
    {
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Test Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Preview with offset=100
        $preview = $this->service->previewNextOrNumber($this->user->id, 100);
        
        $this->assertIsArray($preview);
        $this->assertStringContainsString('000000000100', $preview['or_number']);
        $this->assertEquals(100, $preview['proposed_number']);
        
        // Generate with same offset
        $result = $this->service->generateNextOrNumber($this->user->id, 100);
        $this->assertStringContainsString('000000000100', $result['or_number']);
        
        // Preview next (without offset, should continue from last)
        $preview2 = $this->service->previewNextOrNumber($this->user->id);
        $this->assertStringContainsString('000000000101', $preview2['or_number']);
    }

    /**
     * Test multi-cashier OR generation with stateless offsets.
     */
    public function test_multi_cashier_or_generation_with_offsets()
    {
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Multi-Cashier Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Create second user
        $user2 = User::factory()->create();

        // User 1 starts at beginning (no offset)
        $result1 = $this->service->generateNextOrNumber($this->user->id);
        $this->assertStringContainsString('000000000001', $result1['or_number']);

        // User 2 starts at 50 (stateless offset)
        $result2 = $this->service->generateNextOrNumber($user2->id, 50);
        $this->assertStringContainsString('000000000050', $result2['or_number']);

        // User 1 continues from their last (2)
        $result3 = $this->service->generateNextOrNumber($this->user->id);
        $this->assertStringContainsString('000000000002', $result3['or_number']);

        // User 2 continues from their last (51)
        $result4 = $this->service->generateNextOrNumber($user2->id);
        $this->assertStringContainsString('000000000051', $result4['or_number']);
        
        // User 2 decides to jump back to 10 (stateless offset again)
        $result5 = $this->service->generateNextOrNumber($user2->id, 10);
        $this->assertStringContainsString('000000000010', $result5['or_number']);
    }

    /**
     * Test checking offset conflict before setting (DEPRECATED - for backward compatibility).
     */
    public function test_check_offset_conflict()
    {
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'Conflict Test Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Create second user with offset 20
        $user2 = User::factory()->create();
        $this->service->setCashierOffset($user2->id, 20);

        // Try to set offset 25 for user 1 (should conflict since 20 is within Â±50 of 25)
        $conflict = $this->service->checkOffsetBeforeSetting($this->user->id, 25);
        
        $this->assertTrue($conflict['has_conflicts']);
        $this->assertGreaterThan(0, count($conflict['warnings']));
    }

    /**
     * Test no offset conflict when offsets are far apart.
     */
    public function test_no_offset_conflict_when_far_apart()
    {
        $this->actingAs($this->user);
        
        $series = TransactionSeries::create([
            'series_name' => 'No Conflict Series',
            'prefix' => 'OR',
            'current_number' => 0,
            'start_number' => 1,
            'end_number' => 999999,
            'format' => '{PREFIX}{NUMBER:12}',
            'is_active' => true,
            'effective_from' => now()->startOfYear(),
            'created_by' => $this->user->id,
        ]);

        // Create second user with offset 200
        $user2 = User::factory()->create();
        $this->service->setCashierOffset($user2->id, 200);

        // Try to set offset 1 for user 1 (should not conflict, more than 50 apart)
        $conflict = $this->service->checkOffsetBeforeSetting($this->user->id, 1);
        
        $this->assertFalse($conflict['has_conflicts']);
        $this->assertCount(0, $conflict['warnings']);
    }
}
